@[toc](目录)

## 1. 前言 ##

　　经过一段时间的沉淀，团队类库由原来的 `2.10.0` 提升到了 `2.12.0`。类库内容除了打补丁，还有一些新增内容，甚至还有一些新增成员。本文章主要是说明新增成员情况和新功能的使用。

## 2. 主题内容 ##

 + **project-dependencies  项目依赖管理**

    - `mwf-app-lib-base` 依赖集，包含基础的 mwf-libs 模块

    - `mwf-base-dependencies` 依赖集，除了不包括 `web 资源`，包含完整的 mwf-libs

    - `mwf-security-dependencies` 依赖集，仅包含管理帐号与管理日志模块

    - `mwf-web-dependencies` 依赖集，完整的 `MWF` 框架

 + **macroview-mwf-navigation URL导航项目**

 + **macroview AdminLTE 黑暗主题**

 + **新版本功能介绍**

   - **登录支持 RememberMe 功能**

## 3. project-dependencies  项目依赖管理 ##

## 4. macroview-mwf-navigation URL导航项目 ##

　　目的是为 `MWF` 项目，生成 `URL`（请求）导航界面。

## 5. macroview AdminLTE 黑暗主题 ##

　　黑暗主题界面

## 6. 各类库新版本功能介绍 ##

### 6.1 macroview-lang ###

#### 6.1.1 新增的工具类 ####

 + IdWorkerUtils ：提供 id 生成的默认方法，方便使用

 + RSAKeyUtils：提供 RSA 加密工具方法

 + JsonObject 接口，提供一个 toJson() 方法

 + AnnotationUtils： annotation 的反射工具类

 + TimeDuration：表示时间差

 + Promise 接口：表示成功进行xxx 或 失败进行xxx

 + ExceptionUtils：Exception 方面的工具

 + Joiner：专用于字符串连接

 + @NameMapping：建立名称映射（或别名）的基础注解（ macroview-db 使用，BeanUtils 使用等)

 + NameMappingUtils：获取属性上的 @NameMapping 注解

 + SysUtils：目前提供一些 System.out.println(...) 快速使用的别名

    - SysUtils.p() 相当于 System.out.println()，并且可以有多个字符串参数 SysUtils.p(s1, s2,....)

 + GetSetter：`@NameMapping` 的代码版，即当 `Map` 中存在不符合 `Java` 关键字定义的 `Key` 时（如 `doc.count` 等），实现本接口提供方便取值等

#### 6.1.2 添加新方法的类 ####

 + **`StringUtils`**：常用类

    - indexOfString(s)：返回包含 s 的字符串索引位置
    - indexOfIgnoreCase()： 忽略大小写的 indexOf() 方法
    - deleteSpaces(s)：删除字符串中所有空格，制表符，回车换行等
    - replaceSpaceBy(s, r)：将字符串中的空格，制表符，回车换行替换为 `r`
    - asString(o)：将对象转为字符串
    - tryToString(o, v)：将对象转为字符串时，失败就返回后面 v
    - sprintf(s, objs)：支持 "%s" 占位符的数据替换
    - sprintf(s, t, objs)：支持 "%s" 占位符的数据替换，同时由 t 控制对多余 objs 的处理
    - sprintfByBraces(s, objs)：支持 "{}" 占位符的数据替换
    - sprintf(s, p, t, objs)：支持自定义占位符（参数 `p`)
    - getOrElse(one, two)：如果 one 为空，则返回 two
    - getOrElse(one, Supplier)：如果 one 不为空返回 one，为空由 `Lambda 表达式` 来生成一个返回

 + **`ListUtils`**：List 工具类

    - of(ts)：快速创建一个包含参数给出的元素的不可变列表
    - transform(list, Function)：由一种对象列表，转成另一种对象列表，其中对象转换由 `Lambda 表达式` `Function` 来完成
    - first(list)：返回列表的第一个元素
    - last(list)：返回列表最后一个元素


#### 6.1.3 logger 接口包 ####

　　在 `2.12.0` 版本中，建立一个 `logger` 接口包，提供一个 logger 操作接口，具体的实现由下级类库进行，目前有了一个使用 `Apache Log4j` 实现的类库：

 + `macroview-logger-log4j` （1.0.0）

　　后续会逐步将现有类库从 `Apache Log4j` 中解耦。

#### 6.1.4 Json 接口包 ####

　　在 `2.12.0` 版本中，建立一个 `json` 接口包，提供一个 `json` 操作接口，具体的实现由下级类库进行，目前有了一个使用 `FastJson` 实现的类库：

 + `macroview-json-fastjson` (1.0.0)

　　后续会逐步将现有类库从 `FastJson` 中解耦

### 6.2 macroview-db ###

#### 6.2.1 支持更多的数据库系统 ####

　　新版本将新增支持下述的数据库系统：

 + **informix** 一个同 `oracle` 一样古老，但被 `IBM` 收购的数据库系统，**`UCCX`** 就是使用这个数据库系统

 + **postgresql** 号称能无缝替代 `oracle` 的开源免费数据库系统

 + **Elasticsearch 7.x** 这个需要配合 `elasticsearch-jdbc-driver` （部分支持）

#### 6.2.2 移除 `servlet` 的依赖 ####

　　将原来通过 `servlet` 的 `filter` 实现请求的 `连接` 自动关闭功能，迁移到 `macroview-app-base` 类库，于是从 `2.12.0` 开始，`MD` 不再依赖 `servlet`环境，也就是说不在 `servlet` 容器中运行的应用，也能够使用 `MD` 类库。

　　**注意：不在 `servlet` 环境上使用本类库时，由于没有了 `filter` 的自动关闭连接功能，需要手动关闭连接，否则会让连接池爆掉**

#### 6.2.3 SqlMap 增强表达能力，能对 sql 进行换行 ####

 + 下面是一个示例：

    ```json
    {
        id: "User",

        maps:{
            quryUserByName: "SELECT * FROM ${Table} WHERE name=?",
            queryUserById: "Select * From ${Table} Where id=?"，
            queryTest: '''select * from User
                        Where (id=?) or 
                        (name=?)'''
        }
    }
    ```
        使用 ```sql 语句``` （即三个反引号）来以段落方式编写 sql

#### 6.2.4 细节（方法）添加 ####

 + 添加方法：**findLast()** 和 **findFirst()**

 + `SqlBuilder` API 的 `delete` 方法明确添加异常输出

#### 6.2.5 添加新注解 @NameMapping 为字段提供一个名字映射 ####

　　要注意 `@NameMapping` 是一个名称映射，并非仅仅用于数据库。与 `@Column` 的 JPA 标准注解不同， `@Column` 是将类字段名映射到数据表的字段名，而 `@NameMapping` 是为类的字段名建立一个别名（特别是不符合 Java 标识符命名规范的名称）

　　例如 `private`，这是 Java 的关键字，我们是不能用作类的字段名的，但可以使用 `@NameMapping` 来映射，下面是示例：

 ```java
 public class GiteaReposSearch extends GiteaParams{

    //....

    /**
     * 是否包含私库
     */
    @NameMapping("private")
    private Boolean privateType;

    //....
 }
 ```

　　或者：

```java
//Elasticsearch 的索引信息类
@Entity
@Table(name = "elastic_indices")
public class ElasticIndicesInfo extends HasCreateTimeEntity {

    //....

    @NameMapping("index")
    private String name;
   
    /**
     * 映射
     */
    @JsonField
    private Map<String, Object> mappings;
    
    /**
     * aliases
     */
    @JsonField
    private Map<String, Object> aliases;
    
    /**
     * 记录 rollover 信息
     */
    @JsonField
    private IndicesRolloverInfo rollover;

    /**
     * 记录总数
     */
    @NameMapping("docs.count")
    private long docsCount;

    /**
     * 删除的记录数
     */
    @NameMapping("docs.deleted")
    private long docsDeleted;

    /**
     * 存储大小
     */
    @NameMapping("store.size")
    private String storeSize;

    /**
     * 主片存储大小
     */
    @NameMapping("pri.store.size")
    private String priStoreSize;

    //......
}
```

 + `store.size`、`pri.store.size` 等等，是不能用作 Java 字段名的，在这里建立了一个映射，除了增加可读性之外，也方便编写通用化的代码。

#### 6.2.6 动态添加数据源 ####

　　在之前的版本，为了减少配置和代码，将数据源的配置固定在配置文件上，而在 `2.12.0` 后，我们可以不用配置文件，动态地添加数据库，下面是操作方法：

 + 实现数据源连接接口 `IDbConnectConfig`，如果想更简单一些，直接使用 `DBConnectConfig` （此类实现了 `IDbConnectConfig` 接口)

    - 为连接接口提供：

        + `数据源名称`：`dataSourceName`
        + `数据库名称`：`databaseName`
        + `连接帐号`：`username`
        + `连接帐号密码`：`password`

        ```java

                DBConnectConfig config = new DBConnectConfig();
                
                config.setDataBaseName("app_demo");
                config.dataBaseType(DataBaseType.MySQL)
                      .dataSourceName("MyTempDBSource")
                      .password("macroview")
                      .username("root");
        ```

 + 使用数据源管理类加入数据源：`DataSourceManager.addDataSource(IDbConnectConfig)`

    ```java
        //将数据源配置加入数据源管理器
        DataSourceManager.addDataSource(config);
    ```

 + 有了数据源之后，我们就可以通过数据源名称拿到连接：`DataConnectionManager.getConnection(dataSourceName)`

#### 6.2.7 新的数据表操作基类 DataSetsRepository ####

　　在之前的版本，我们都会以 `Entity`（实体类）为基础操作数据表，但在某些场合下，我们希望接触到一些底层的内容，如记录集，数据行之类的。新版本引入的基类 `DataSetsRepository` 可以满足大部分的需求。

 + `DataSets`：记录集，包含了简单的字段名与数据行的内容

 + `DataSetsRepository`：提供记录集的操作的基类，提供一些查询方法

    - 主要是查询方法，包括执行查询语句，简单的分页等
    
    - 可以动态切换：

        + 所使用的数据源
        + 所使用的数据库（即同一数据源不同数据库）
        + 无论是使用数据源或动态改变数据库，都会影响到连接池，因此要确保切换时，连接池的连接都能正常释放

#### 6.2.8 使用注解来定义事务（功能有限，且为测试版本） ####

　　新版本配合新的 `macroview-container`，引入事务注解：

 + `@Transaction`：定义在类上，表示此类为事务类

    - 使用属性：`value` 来表示需要事务的方法，以下为默认支持事务的方法

        + `save*`：即以 `save` 为前缀的方法，如果 `saveDevice`
        + `insert*`：以 `insert` 为前缀的方法，如 `insertUser`
        + `update*`：以 `update` 为前缀的方法，如 `updateUser`
        + `delete*`：以 `delete` 为前缀的方法，如 `deleteUser`
        + `edit*`：以 `edit` 为前缀的方法
        + `create*`：以 `create` 为前缀的方法

 + `@Transactional`：定义在方法上，关闭此方法的事务性。由于 `@Transaction` 对整个类的方法有效，当我们希望某个方法不需要事务(例外)，可以使用本注解

    - 属性：`readOnly` ，如果值为 `true` 表示此方法不需要事务

        ```java
        @Transaction
        public class UserService {

            //需要事务
            public boolean deleteUser(){
                //....
            }

            //不需要事务
            @Transactional(readOnly=true)
            public User createUserBy(UserUpdateBean bean){
                //..
            } 
        }
        ```

### 6.3 macroview-app-security 登录认证 ###

　　提供的新功能如下：

 + 提供 `RememberMe` 支持
 + 

#### 6.3.1 RememberMe 的使用 ####

 + 新增配置，用来开启或关闭 RememberMe： LoginConfig.rememberMe

    - 对应配置表 `sysconfig` 中的配置：LoginConfig, rememberMe, true|false

 + 新增表：login_rememberme 用来记录帐号的 `RememberMe` 使用

 + 帐号查询接口：`LoginAccountService` （定义在：`macroview-app-base` 中）

    - 在类库 `macroview-app-user`(2.12.0)中已经实现此类库，如果不使用此类库需要自己实现

### 6.4 macroview-http-client Http 客户端请求库 ###

　　在 `2.12.0` 版本，为了让 `httpclient` 更有可用性，将 `macroview-web-lang` 分拆成两大部分：

 + `macroview-http-client`：只提供 `httpclient` 的工具操作，这样可以在通用环境中也能使用（旧版本需要 `servlet` 环境）

 + `macroview-web-utils`：除了 `httpclient` 之外的内容，如一些 `servlet` 工具等

　　除了独立成类库之外，新版本还在细节上进行了更新，并且引入了 `异步请求` 的封装，使用 `Apache HttpAsyncClient` 的异步请求库来实现。

#### 6.4.1 异步的 HttpClient 请求的使用 ####

　　所谓 `异步请求` 就是指发起请求后，不需要等待请求结果，就可以继续执行下去，而请求的结果将会以回调的方式来提供并处理，所以 `异步请求` 的优势在于：

 + 无需要等待即可处理其他任务，适合于不用等待结果的处理场景

 + 高并发环境，能够提供良好的性能。（多线程，不需要等待）

　　相应地 `同步请求` 则是发起请求后，要等等请求结果，这个等待很容易让整个系统的主线程处于空闲状态，这样不利于高并发与高压力的场景。不过，从别一个角度来看，如果使用场景比较单一，又或者低并发的环境，`异步请求` 由于 `异步` 的管理，反而成了 `缺点`，此时通常使用 `同步请求` 会比 `异步请求` 更好。合理使用，才是正道。

　　异步请求的使用，跟同步请求基本一样，唯一的区别在于：异步请求需要提供一个回调。

 + **`HttpServerResponseCallback`**：这是回调

   ```java
      @FunctionalInterface
      public interface HttpServerResponseCallback {

         /**
         * 回调
         *
         * @param response
         */
         public void handle(HttpServerResponse response);
      }
   ```   

   接口只有一个方法，请求完成后（无论是成功还是失败），内容封装在 `HttpServerResponse` 中

 + **`HttpAsyncClient`**：核心方法实现类，提供了各种请求处理方法，不过如果不追求细致的自定义参数的话，使用 `HttpAsyncClientUtils` 会更简单一些

 + **`HttpAsyncClientUtils`**：日常使用类

   这个类在内容创建了一个 `HttpAsyncClient` 对象，然后定义了一堆静态方法来提供使用，一般来说，如果应用不是高并发，或者大量的请求处理情况下，使用本工具类就足够应对

　　下面是一些使用示例：

 + 发起一个简单的 `GET` 请求：（使用 `HttpAsyncClientUtils`）

   ```java
   public class HttpAsyncClientTest {

      @Test
      public void get(){
         HttpAsyncClientUtils.get("http://172.22.251.121:8080", (response)->{
            
            response.anyway(
                        r->SysUtils.p(r.getResponseString())
                     )
                    .ifException(e->SysUtils.p(e));
         });         
      }
   }
   ```
   在回调中处理结果（示例的回调是一个 `Lambda 表达式`）

 + 发起一个 `POST` 请求：（使用 `HttpAsyncClientUtils`）

   ```java
    @Test
    public void postJson() {
        DataObject d = DataObject.createBy(RandomStringUtils.randomAlphabetic(6), 21, new Date());
        
        //res 就是 HttpServerResponse 对象，res.getValue() 以字符串形式得到请求返回结果
        client.post(
                "http://localhost:8080/macroview-mwf-example/json/data-object", 
                JSON.toJSONString(d),  //转为 json 字符串

                (res)->{
                    SysUtils.p("===> postJson():");
                    if(res.isSuccess()) {
                        SysUtils.p(JSON.toJSONString(res.getValue()));
                    }else {
                        SysUtils.p(res);
                    }
                    SysUtils.p("===> postJson() 结束 ------------");
                }
        );
    }
   ```

### 6.5 macroview-web-framework ###

　　主要是一些细节上的可定制化更新。

#### 6.5.1 请求注解新增属性 ####

　　为了配合 `macroview-mwf-navigation` 项目，用于生成完整的项目 `URL` 导航路径，`Get`、`Post`、`Put`、`Delete`四个基础注解添加了以下属性：

 + `name`：为请求提供一个名称，通常解释此请求的用途。默认值为空，取方法名称作为值。

 + `description`：简明描述，用来解释请求的意义、用途或如何使用等

 + 示例使用：

    ```java
        @Get(value="/", name="获取所有用户信息", description="返回所有用途信息记录")
        public ListResult<User> allUsers(){
            //...
        }
    ```

#### 6.5.2 新增或变更一些定制化注解 ####

 + `@ResponseStrategy`：响应注解在原有的基础上，添加一个新的属性（仅用于 `JSON` 格式的返回）

    - `responseConverter`：这个属性指向一个返回转换接口 `ResponseBodyConverter` 实现类，可以用来定制请求方法的返回，默认值为 `DefaultResponseBodyConverter` 这个简单的返回实现（将 `json` 字符串转为 Java 对象）

    - 当我们需要对某些特定的对象，定制其返回类型时，可以自己实现 `ResponseBodyConverter` 接口。

        ```java
            public interface ResponseBodyConverter {

                /**
                * 将结果 response 进行转换，最终返回一个字符串（通常是 JSONString 或 XMLString）
                *
                * @param servlet			请求的上下文（得到 Request 和 Response）
                * @param methodMapping		方法的映射配置（例如方法上的注解等）
                * @param response			请求方法的返回值
                * @return
                */
                public String convert(
                                ServletData servlet, 
                                RequestAndMethodMapping methodMapping, 
                                Object response);
            }
        ```

 + `@RequestPreHandler`：新增的一个注解，用于对请求方法参数进行处理的注解。（仅用于 `JSON` 格式的请求）

    - 当我们需要将客户端提交的 `JSON` 字符串，转换到请求方法的参数时，当此参数为特定类型（如自定义的接口，或者包含了一些自定义接口，泛型等），用 `MWF` 的默认转换方法并不能进行转换，此时需要我们编写定制的转换方法

    - 注解只有一个属性：`argumentHandler`，为接口 `ActionMethodArgumentHandler` 的类型

        ```java
        public interface ActionMethodArgumentHandler {

            /**
            * 处理方法
            *
            * @param argumentContext   包含了方法，请求上下文，参数类型，路径值等，同时包含原始类型
            * @param clazz             参数类型，包括了泛型类型
            * @param value             为非路径值时，使用此值
            * @return
            */
            public Object handle(ResolveArgumentContext argumentContext, Class<?> clazz, String value);
        }
        ```

    - 示例：（示例中的参数 `Json datas`，`Json` 是一个接口，对于 json 类库而言，并不知道如何转换）

        ```java
            /**
            * 从 Elastic 中返加快照仓库
            *
            * @param serverID
            * @param datas         客户端提交数据
            * @return
            */
            @Post("/{serverID}/repositories")
            @RequestPreHandler(argumentHandler = JsonRequestBodyConverter.class)
            @ResponseStrategy(responseConverter = JsonResponseBodyConverter.class)
            public JsonResult createElasticsearchRepositories(@PathVariable String serverID, Json datas) {

                //...
            }
        ```
        + `Json` 是一个接口，所以需要定制转换，下面是 `JsonRequestBodyConverter` 的实现。

            ```java
            public class JsonRequestBodyConverter implements ActionMethodArgumentHandler{

                /**
                * 将数据转换
                */
                @Override
                public Object handle(ResolveArgumentContext argumentContext, Class<?> clazz, String value) {
                    if(ReflectUtils.isInheritance(clazz, List.class)) {
                        return FastJsonUtils.parseArray(value, clazz);
                    }
                    return FastJsonUtils.parseObject(value, clazz);
                }
            }
            ```
        + `JsonResult`：这个返回值，其实也包含了一些接口内容，所以也加上了一个 `@ResponseStrategy` 来定制返回

 + `@ScanIgnore`：支持在应用启动时，忽略 `interceptor` （拦截器）。即不自动加入添加了 `@ScanIgnore`的拦截器

#### 6.5.3 一些其他细节的内容 ####

 + 当请求方法的返回值是 `Result` 或其子类时，将不再返回 `exception` 堆栈信息。（加强安全性举措）

 + 对输出的调试信息，也建立不再显示一些敏感的内容（如输入的密码等内容）

 + 移除依赖 `macroview-http-client`，本类库不再需要依赖此类库

 + 修复了请求方法中，无法使用 `List` 作为参数类型的 BUG 等

