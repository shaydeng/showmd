
@[toc](目录)

## 1. 前言 ##

　　**`注意：目前此版本仍然处于开发当中，暂不保证所有新功能处于稳定状态`**

## 2. 主题内容 ##

## x3. 具体的类库新增功能 ##

### x3.1 Macroview-DB 数据库操作类库 ###

#### x3.1.1 将原来位于 `Macroview-App-Base` 的一些数据库基类移到本库 ####

　　将原来在 `Macroview-App-Base` 中的数据基类及分页基类，移到本类，以加强本类的独立性和功能，使其有更广泛的使用性。主要包括了下面两个包：（迁移后，包名不变，不影响到原有的系统，即向下兼容）

 + `com.macroview.app.commons.base` 中的数据库部分类
 + `com.macroview.app.commons.page` 用于分页的类

#### x3.1.2 多数据源使用 ####

　　在以往的版本，通常假定每个数据库都会有不同的结构（表），因此针对性地每个数据源，都会有一套独立的实体类继承体系。但随着越来越多云端的应用或数据分库的预期出现，同一实体结构不同数据源的情况出现，以往的版本处理起来就不态方便，因此在新版本中，特别引入方便切换数据源的内容。

 + **`MultiDataSourceEntity`**：引入新的实体类基类，此类继承于 `HasCreateTimeEntity`。提供方法

    - `T ofDataSource(dataSource)`：用于切换到不同的数据源
    - `T ofDefault()`：重置回默认的数据源
    - `void useDataSource(dataSource, ExConsumer)`：提供以 `Lambda` 方式进行操作，完成后自动重置回默认数据源
    - `R useDataSource(dataSource, ExFunction)`：同上，不同的地方在于本方法可以返回一个值，例如直接返回一个列表等
    - 要注意：**`所有的切换动作是有状态的，因此也是线程不安全，并且一直影响到后续操作`**

 + 下面是使用示例：

```java
  @Entity
  @Table(name="user")
  public class MyUser extends MultiDataSourceEntity {

      private String name;

      //... 其他代码
  }

  //使用，注意：由于是有状态，所以不建议创立类全局静态变量，如 DAO 使用    
  MyUser user = new MyUser();
  try{
      List<MyUser> users = user.ofDataSource("Macroview").findBy(....); //使用数据源 Macroview 来查询数据
  }finally{
      user.ofDefault();  //重置回默认的数据源，此为可选。
  }
```

```java
  @Entity
  @Table(name="user")
  public class MyUser extends MultiDataSourceEntity {

      private String name;

      //... 其他代码
  }

  //使用，注意：由于是有状态，所以不建议创立类全局静态变量，如 DAO 使用    
  MyUser user = new MyUser();
  //...使用 Lambda 表达式，要注意传入的参数 u 就是 user 本身，数据源已经切换到 Cisco
  user.useDataSource("Cisco", (u)->{
      MyUser exists = u.findUniqueBy("name", "David");
      if(exists == null){
          u.save(); //保存到数据源 Cisco 
      }
  });  
  // lambda 表达式执行完后，自动回复到默认数据源
```

#### x3.1.3 新的查询注解 ####

 + **`@GroupBy`**：定义 `Group By` 操作

    - `byFieldValue`：属性，决定使用字段名称还是字段值做 `Group By`，默认值为 `false` 即使用字段名称

    - 示例：

     ```java
       public class UserQueryBean {

            private String name;

            //对字段 userType 进行分组
            @GroupBy 
            private String userType;

            //... 
       }
     ```  

#### x3.1.4 事务处理 ####

　　以前的版本，事务由一个单独的 `TransactionFactory` 类进行处理，为了方便使用，在实体类的基类也提供了事务方法，可以通过实体类来使用事务。

```java
   User.DAO.beginTrans();
   try{
       //do something...

       User.DAO.commit();
   }catch(Exception e){
       User.DAO.rollback();
   }
```

#### x3.1.5 新方法添加 ####

 + `BaseRepository`

    - `escape(field)` 为字段添加表名前缀，替代手工 `User.DAO.TableName() + ".[userName]"` 写法

        + 改成 `User.DAO.escape("userName")`

#### x3.1.6 数据池配置 ####

　　在之前的版本，我们都默认使用 `ali druid`（阿里开源的 druid）连接池，作为唯一连接池。如果需要换其他的连接池时，可以通过编写代码手工加入。

　　在 `2.14.0` 这个版本，提供了一种新的替换连接池的方法，具体如何：

 + **`DataSourceCreator`**：创建此接口的实现类，用来创建连接池（数据源）

 + **`DBPoolManager.addCreator(name, DataSourceCreator)`**：将 `DataSourceCreator` 实现类起个名称，加入到管理器

 + **`md.DatabasePool=name`**：在数据池配置文件 `druid.properties` 中添加 `md.DatabasePool=name` 配置项，这里的 `name` 与上面第二部的名称要一致

#### x3.1.7 SmallDataSource 不带池的数据源 ####

　　数据池的目标在于，不需要每次重新连接，就能进行数据处理工作。这样也带来一些额外的内容：

 + 多个共享的长连接
 + 需要额外的资源

　　而在一些应用当中，数据库操作较少，连接池的作用不明显，反而在意额外的资源消耗时，不使用连接池是一种选择。虽然连接池能通过配置，降低池中连接数或资源消耗，但又 `何苦`呢。

　　又或者一些数据库（特别是本地或内嵌型），本身就不支持多任务多连接（即每次只能有一个连接），使用连接池反而是一个累赘。此时可以尝试使用 `SmallDataSource`。

　　在 `2.14.0` 开始引入了不带池的数据源实现: `SmallDataSource` ，这个数据源很简单，不带连接池，每次获取连接都是新连接。

　　使用方法比较简单：

 + 在配置文件 `druid.properties` 或其他 `properties`（数据源配置）文件中，添加配置项 `md.DatabasePool=simple` 即可。

#### x3.1.8 DataBaseType 的转变 ####

　　在 `2.14.0` 中，为了方便在外部引入新数据库的支持，将 `DataBaseTyp` 由枚举类型修改为接口类型。

　　`DataBaseType` 接口的内容：

 + `NativeSQL getNativeSQL();` 数据库的一些自己特有的内容，例如引导符，前 `n` 条记录在 `select` 语句中的表示等

 + `String getJdbcDriverName();` `JDBC` 驱动类名

 + `String getUrlPattern();` `JDBC` URL 的表示格式

    - 例如 MySQL 的 URL 格式 `jdbc:mysql://${dbServerIp}:${dbServerPort}/${dbName}?generateSimpleParameterMetadata=true`
    - 通常包含以下几部分：

        + 驱动的分类标识，`jdbc:mysql` -- 表示为 `MySQL` 的 URL，`jdbc:sqlserver` 则是 `MSSQLServer`
        + 数据库服务器地址与端口，如果是本地数据库，可能为 `localhost` 或 省略
        + 要连接的数据库名称
        + 后面是常用的连接参数等

 + `NativeDDLScript getNativeDDLScript()` 数据库系统的库与表创建语句形式

    - 也包括了类型与 `JDBC` 类型的映射

 + `String name();` 数据库名称

 + `IDbConnectConfig parse(String url)` 给出一个具体的 `JDBC URL`，然后分拆成几部分（如上面所述）

 + `boolean isMe(String jdbcUrl)` 判断给出的 `JDBC URL` 是否为本类型的驱动

    - 如 `url = jdbc:mysql://localhost:3306/test` `MySQL` 类型通过 `jdbc:mysql` 前缀来判断，这是 `MySQL` 的连接


#### x3.1.9 在外部以插件形式添加数据库驱动支持 ####

　　在 `2.14.0` 之前的版本，如果要添加新的数据库支持，需要在类库添加相应的代码，所以每次添加都意味着类库的升级。因此，有必须开放类库的这方面的内容，以方便在外部添加（不修改类库）。

　　在 `2.14.0` 版本中，引入简单的 `驱动插件` 的概念，只需要实现插件接口的方法，即可让 `MD` 自动获得支持。

 + `MDDriverPlugin`：驱动插件接口，主要内容

    ```java
    public interface MDDriverPlugin {

        /**
        * 提供一个完整的数据类型描述
        *
        * @return
        */
        public DataBaseType getDataBaseType();
        
        /**
        * 数据表的创建
        *
        * @return
        */
        public TableCreator getTableCreator();
    }
    ```
    - `DataBaseType getDataBaseType()`：实现数据库类型的描述
    - `TableCreator getTableCreator()`：如何创建表，这用于数据表的自动创建操作，如果不需要可以返回 null

 + `驱动插件` 在系统启动时，自动扫描加载，因此一般只需要实现即可


### x3.2 Macroview-Lang 基础工具类库 ###

#### x3.2.1 java.util.function 包中的函数接口带异常增强 ####

　　Java8 的一个强大的地方是引入 `Lambda`，同时提供了一些函数接口，如 `Function`, `Consumer` 等，但有一个不便的地方在于，如果函数操作会产生异常时，使用起来就有点 `丑`。例如：

```java
    list.foreach((u)->{

        try{
            //.... do something..
        }catch(Exception e){

        }

    });
```

　　引入了新的对异常友好的接口后，可以写成：

```java
    //异常将转为 RuntimeException 由外层进行处理
    list.foreach(Attempt.accept(u->{
        //...do somthing
    }));
```

　　相对就好看多了。
　　目前支持的函数接口：

 + ExConsumer       -----> Consumer
 + ExBiConsumer     ----> BiConsumer
 + ExFunction       ----> Function   
 + ExBiFunction     ----> BiFunction
 + ExSupplier       ----> Supplier

　　另外还添加了一个 `Attempt` 工具，用来将 `Ex` 系列的接口转为对应标准的接口，如： Attempt.accept(ExConsumer) --> Consumer ，方便使用。

#### x3.2.2 Result 的子类的变化 ####

　　关于 `com.macroview.commons.base.result` 中的众多 `Result` 类，最初的设想是创建一个简单易用的返回结果集，目标：

 + 简单易于使用

 + 减少 Exception 的干扰

 + 有一个统一的处理接口，特别是 REST API 方面。

 + 如果返回是一个明确的值，没有异常也没有错误，不建议使用 `Result` 或子类

 + `Result` 应该是不可变的，但可以转（或拷贝）成其他对象

　　但是，由于 Java 的一些限制等，添加了越来越多的内容，变得越来越臃肿难用，有很多没什么用的，或者很少用的内容，因此从 `2.14.0` 开始，将逐步简化内容:

 + `AbstractWithMessageResult` 类将重构成 `BaseDataResult`，内容将移到此类，也有部分移到 `AbstractResult`，并且: 

    - `BaseDataResult` 不是抽象类，是可以创建对象的
    - 其他继承于 `AbstractWithMessageResult` 的类，变成继续于 `BaseDataResult`

 + 按照 `Result` 的设计理念，逐步移除更新方面的内容

    - `Result` 接口中的静态方法迁移到新的 `ResultUtils` 类，`ResultUtils` 原来的内容融入到 `BaseDataResult`

    - `Result` 的方法 `arrays()` 与 `collections()` 移到 `ListResult` 子类

    - `Result` 的方法 `mapWrapper()` 移队，在 `MapResult` 已经有类似的方法 `toWrapper()`

#### x3.2.3 Day 日期时间工具类 ####

　　`Day` 类表示一个日期时间，提供非常多的方法，在 `2.14.0` 中新增如下方法：

 + inMinutes(d, m) -- 在最近几分钟内，如果是返回 true，否返回 false
 + inSeconds(d, s) -- 在最近几秒内，如果是返回 true，否返回 false
 + inDays(d, d) --- 在最近几天内，如果是返回 true，否返回 false
 + lastMinutes(m)  --- 最近几分钟内（与现在比），如果是返回 true，否返回 false
 + lastDays(d)     --- 最近几天内（与现在比），如果是返回 true，否返回 false

#### x3.2.4 Json 工具包 ####

　　实现在 `macroview-json-fastjson`。新增了更加方便使用的内容：

 + **`JsonTools`**：这是一个静态方法工具类，提供了大部分的 `Json` 功能，所以在大多数场合，直接使用本类即可

    - **`Json parseObject(json)`**：反序列化 `json` 字符串成一个 `Json` 对象
    - **`T parseObject(json, Class<T>)`**：反序列化 `json` 字符串成一个 `Class<T>` 类对象
    - **`List<T> parseArray(json, Class<T>)`**：反序列化 `json` 字符串成一个 `Class<T>` 类对象数组
    - **`Json toJson(O)`**：将一个对象转成一个 Json 对象，目的是方便使用，如将一个 Map 转成 Json 等
    - **`toJSONString(o)`**：将对象 o 序列化成一个 `json` 字符串
    - **`formatOutput(o)`**：序列化 o 成 `json` 字符串，然后格式化输出
    - **`toJSONString(o, JsonSerializerOptions)`**：使用条件对 o 进行序列化

        ```java
        User u = ...;
        String json = JsonTools.toJSONString(u);

        User admin = JsonTools.parseObject(json, User.class);
        ```

#### x3.2.5 Logger 日志 ####

　　实现在 `macroview-logger-log4j`，新增了更加方便的使用：

 + **LoggerTools**：这是一个静态工具类，可以用来创建 `Logger` 接口的实现方法，提供了以下的方法：

    - **`Logger of(name)`**：使用名称创建 `Logger` 接口的实现类
    - **`Logger of(Class)`**：使用类来创建 `Logger` 接口的实现类

        ```java
            Logger myLogger = LoggerTools.of("MAIN");
            myLogger.info(....); //输出 INFO 类型日志
            myLogger.error(....); //输出 ERROR 类型日志
        ```

#### x3.2.6 移走 BaseTestHasLog4j ####

　　`BaseTestHasLog4j` 是用来测试的类，在 `2.14.0` 版本中将移到一个新类库 `macroview-tests`。

　　当需要使用此功能时，加入 `macroview-tests` 的依赖。

```xml
    <dependency>
        <groupId>com.macroview</groupId>
        <artifactId>macroview-tests</artifactId>
        <scope>test</scope>
    </dependency>
```

### x3.3 Macroview-Web-Framework ###

　　在 `2.14.0` 当中，`MWF` 的变化比较大，之前的版本是使用 `Servlet` 的注释，以固定形式在容器启动时，注册到容器。这种做法有个不好的地方在于，无法灵活定义 `MWF Servlet` 映射的路径。

　　这种情况，当我们需要引入 `Spring Boot` 的内容时，会有麻烦。所以新的 `MWF` 版本拆分成两个项目：

 + **Macroview-Web-Framework**：项目保留原来的自动注册到容器的功能（也仅如此而已）

 + **Macroview-webmvc**：则包含了原 `MWF` 大部分的功能，唯一区别就是不能自动注册

    - 本项目不依赖于 `macroview-web-framework`，所以可以单独使用。

　　`macroview-web-framework` 依赖于 `macroview-webmvc` 项目，**所以在使用上没有任何区别**。但当我们需要手动，又或者需要配置 `MWF Servlet` 映射到其他路径时（默认映射到 `/`，如想映射到 `/midas/**`），可以直接使用 `servlet` 注册方法直接注册。

　　注意：对于 `MWF 项目` 而言，这个变化并不影响使用。也就是说，原来怎样使用，现在还是这样使用。



