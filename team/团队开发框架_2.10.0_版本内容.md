@[toc](目录)

## 1. 前言

　　经过一段时间的沉淀，团队类库由原来的 `2.8.0` 提升到了 `2.10.0`。类库内容除了打补丁，还有一些新增内容，甚至还有一些新增成员。本文章主要是说明新增成员情况和新功能的使用。

## 2. 主题内容

 + **project-dependencies  项目依赖管理**

 + **embedded-server-starters 嵌入服务器类库**

 + **新版本功能介绍**


## 3. project-dependencies  项目依赖管理

　　每个依赖项（类库）都会有不同的版本，当修改项目的依赖项版本时，逐个修改显得比较麻烦，而引入依赖库管理，将简化这种操作。

　　目前 `project-dependencies` 提供的依赖管理将从 `2.10.0` 这个版本开始。（其实也提供 `2.8.0`，不过不太完善），下面说明其使用方法。

#### 3.1.1 添加依赖管理

　　在 `pom.xml` 中加入下述的依赖管理项：

```xml
    <!-- 添加依赖管理项 -->
    <dependencyManagement>
       <dependencies>
            <dependency>
                <groupId>com.macroview</groupId>
                <artifactId>project-dependencies</artifactId>
                <version>2.10.0</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>
```

　　也可以将这个依赖库作为项目的父项目，也就是在 `pom.xml` 中添加：

```xml
  <parent>
    <groupId>com.macroview</groupId>
    <artifactId>project-dependencies</artifactId>
    <version>2.10.0</version>
  </parent>
```

　　其效果是一样的。

#### 3.1.2 项目依赖不需要给出版本号

　　版本由依赖管理项来管理，所以在输入依赖库时，不需要写版本号。这样，只需要在依赖管理项中修改版本号，所有依赖此管理项的项目，就自动使用新版本号。

```xml
<dependencies>
    <dependency>
        <groupId>com.macroview</groupId>
        <artifactId>macroview-lang</artifactId>
    </dependency>
    <dependency>
        <groupId>log4j</groupId>
        <artifactId>log4j</artifactId>
    </dependency>
 
    <dependency>
        <groupId>com.alibaba</groupId>
        <artifactId>druid</artifactId>
    </dependency>
 
    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
    </dependency>
    <!-- ..... -->
</dependencies>
```

　　换句话说，在编写依赖时，不需要明确给出版本号，这个版本号由 `Maven` 从依赖管理项中得到。


## 4. embedded-server-starters 嵌入服务器类库

　　嵌入服务器类库的最大特点就是可以将系统打包成一个可执行的 `jar`文件，然后可以直接拷贝到 `java`环境中运行，不需要特别准备一个 `Servlet` 容器，是一种便携式的使用，也为方便将来在类似 `Docker` 这样的容器中运行。

　　目前 `embedded-server-starters` 支持以下两种服务器：

 + **Tomcat**(8.5.32)

　　`Tomcat` 支持完整的 `Servlet` + `JSP` 应用。

 + **Undertow**(1.4)

　　`Undertow` 目前只支持 `Servlet`应用

### 4.1 类库的使用

　　类库的使用非常简单，有两种使用方式：

#### 4.1.1 已经项目或普通项目

　　对于已有 `Web` 项目，又或者创建一个 `Java` 项目，可以在 `pom.xml` 中添加下述的依赖：

 + **在 pom.xml 文件中添加内容**

```xml
  <!-- 添加类库依赖 -->
    <dependencies>
        <dependency>
            <groupId>com.macroview.mwf</groupId>
            <artifactId>embedded-server-commons</artifactId>
        </dependency>

        <!-- 使用 Tomcat 服务器，Tomcat 与 undertow 只能选其一 -->
        <dependency>
            <groupId>com.macroview.mwf</groupId>
            <artifactId>embedded-tomcat-starter</artifactId>
        </dependency>

        <dependency>
            <groupId>com.macroview.mwf</groupId>
            <artifactId>embedded-server-starter</artifactId>
        </dependency>

        <!-- 使用 undertow 服务器，Tomcat 与 undertow 只能选其一 -->
        <dependency>
            <groupId>com.macroview.mwf</groupId>
            <artifactId>embedded-undertow-starter</artifactId>
        </dependency>
    </dependencies>

  <!-- 添加依赖管理项 -->
    <dependencyManagement>
       <dependencies>
            <dependency>
                <groupId>com.macroview.mwf</groupId>
                <artifactId>embedded-server-starters</artifactId>
                <version>2.10.0</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>

            <dependency>
                <groupId>com.macroview</groupId>
                <artifactId>project-dependencies</artifactId>
                <version>2.10.0</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>
```

 + **创建 Main 方法**

　　创建 `main` 方法的目的就是单个可执行 `jar` 文件，下面最简单的实现代码：

```java
    /**
     * 根据环境启动不同的服务器
     *
     * @param args
     */
    public static void main( String[] args ){
        
        EmbeddedServer server = new EmbeddedServer();
        
        server.start();
    }    
```

　　很简单，没有太多的内容。当然，如果不想自己写 `main` 方法，也可以用已经定义好的 `main` 方法：

 **com.macroview.mwf.embedded.app.MwfStandarMainApplication**

　　这个类定义在 `embedded-server-starter`中，可以在 `pom.xml` 中直接引用。


#### 4.1.2 使用 Maven archetype 来创建新项目

　　除了 `4.1.1` 方法之外，我们还定义了两个 `Maven archetype`（项目骨架）来自动创建 `Embedded Server` 项目：

 + **embedded-tomcat-archetype** 用来创建基于 Tomcat 的项目
  
 + **embedded-undertow-archetype** 用来创建基于 Undertow 的项目 

　　要用我们定义的 `maven archetype`，你需要在 `eclipse` 中创建本地 `archetype` 引用，方法可以参考下面文章的第6节内容。（当然，如果曾经配置过的话，就不需要再配置）

 [**Eclipse Archetype 配置**](./eclipse/README.md)


### 4.2 即支持在 `Eclipse` 中调试，又可以打包成 Jar APP

　　单`Jar`包可执行文件，带来一些优点的同时，也存在一些不足地方，例如在 `Eclipse` 进行调试时，不能象调试传统 `web` 程序那样，对程序或资源作修改后，`Eclipse`会自动部署和加载。

　　换言之，当修改了代码或资源（如 JSP 文件）后，需要手动关闭正在运行的程序，然后再启动。特别是在编写或调试 `JSP`之类的文件，需要手工关闭再启动，不象传统那样自动化。

　　解决的方法，例如 `Spring Boot` 是通过开发一个 `Maven` 插件来解决，另一种解决方法就是充分使用 `Maven`的特性来实现，下面所介绍的方法，就是利用 `Maven Profile`来实现。

　　利用 `Maven Profile` 来定义项目的场景：

 + 有 Eclipse 进行调试时，以 `Web` 项目的形式存在。（war 包）
  
 + 真正打包部署时，则打包成 `Jar` 文件。（单可执行文件）

　　这样，即可以在 `Eclipse`进行调试时，能够象传统的 web 项目那样调试；同时在部署时，能够变成单 `Jar`包执行文件，方便部署运行，下面是简单的操作步骤：

 + 以 web 形式来创建项目。
  
 + 修改 `pom.xml` 文件 

　　下面用示例来说明如何修改：

```xml
<project  .....>

    <artifactId>xxxxx</artifactId>
    <packaging>${package.type}</packaging> <!-- 这个一定要，使用变量来控制打包成 war，还是 jar -->

    <dependencies>
        <!-- war 和 jar 都需要的公共库 -->
    </dependencies>
    <!-- 省略... -->

    <!-- 定义不同场景的 profile  -->
    <profiles>
        <profile>
            <id>packageWar</id> <!-- War 形式的场景 -->
            <activation>
                <activeByDefault>true</activeByDefault> <!-- 将这个 war 作为主场景 -->
            </activation>

            <properties>
                <package.type>war</package.type> <!-- 定义变量值 -->
            </properties>

            <dependencies> <!-- 打 war 包才会用的库 -->

                <dependency>
                    <groupId>com.macroview</groupId>
                    <artifactId>macroview-app-web-base</artifactId>
                    <type>war</type>
                </dependency>

                <dependency>
                    <groupId>com.macroview</groupId>
                    <artifactId>macroview-app-web-config</artifactId>
                    <type>war</type>
                </dependency>

                <dependency>
                    <groupId>com.macroview</groupId>
                    <artifactId>macroview-web-resources</artifactId>
                    <type>war</type>
                </dependency>

            </dependencies>

        </profile>

        <profile> <!-- 第二个场景 -->
            <id>packageJar</id> <!-- 打成 jar 包的场景配置 -->
            <activation>
                <activeByDefault>false</activeByDefault>
            </activation>

            <properties>
                <package.type>jar</package.type>
            </properties>

            <dependencies>
                <dependency>  <!-- 打 jar 包才会用的库 -->
                    <groupId>com.macroview.mwf</groupId>
                    <artifactId>embedded-server-commons</artifactId>
                </dependency>

                <dependency>
                    <groupId>com.macroview.mwf</groupId>
                    <artifactId>embedded-tomcat-starter</artifactId>
                </dependency>

                <dependency>
                    <groupId>com.macroview.mwf</groupId>
                    <artifactId>embedded-server-starter</artifactId>
                </dependency>

                <dependency>
                    <groupId>com.macroview</groupId>
                    <artifactId>jsp-taglib</artifactId>
                </dependency>

                <dependency>
                    <groupId>com.macroview</groupId>
                    <artifactId>macroview-app-admin-base</artifactId>
                </dependency>
                <!-- 省略。。。 -->

            </dependencies>

            <build>
                <resources>
                    <resource>  <!-- 打包时，将 web 内容打包到 jar，并放到根目录中 -->
                        <directory>src/main/webapp</directory>
                        <includes>
                            <include>**/**</include>
                        </includes>
                        <targetPath>./</targetPath>
                    </resource>
                </resources>

                <plugins>
                    <plugin> <!-- 可执行 jar 打包的插件 -->
                        <groupId>org.apache.maven.plugins</groupId>
                        <artifactId>maven-assembly-plugin</artifactId>
                        <version>2.5.5</version>
                        <configuration>

                            <archive>
                                <manifest> <!-- 这里填写实现 main 方法的类 -->
                                    <mainClass>com.macroview.mwf.embedded.app.MwfStandarMainApplication</mainClass>
                                </manifest>
                            </archive>
                            <descriptorRefs> <!-- 表示将依赖的 jar 文件也打包进去 -->
                                <descriptorRef>jar-with-dependencies</descriptorRef>
                            </descriptorRefs>

                        </configuration>
                        <executions>
                            <execution>
                                <id>make-assembly</id>
                                <phase>package</phase>
                                <goals>
                                    <goal>single</goal>
                                </goals>
                            </execution>
                        </executions>
                    </plugin>
                </plugins>

            </build>

        </profile>
    </profiles>
</project>
```

　　定义好了之后，就可以在 `Eclispe`中将项目添加到 `Tomcat`中进行调试。调试完成之后，需要部署时，可以使用下面的 `Maven` 命令来打包成 `Jar` 文件：

  **mvn package -PpackageJar -Dmaven.test.skip=true**  (注意，参数 -P 是大写)

　　`Maven`会很聪明的将所需要的内容打包成一个可执行 `Jar` 文件。

## 5. 新版本功能介绍

　　在这次类库升级中，很多类库是直接修改版本号，同时也有一些是打补丁和添加方法或类，只有 `Macroview DB`这个类库的功能有一个大的提升，下面讲一些类库的变代，而重点介绍 `Macroview DB`的新功能。

### 5.1 Macroview-container 2.10.0

 + 新增 **@Ignore**注解，添加了此注解的类，容器不会处理这个类。

　　当希望某个类能兼容其他框架或类库，但在没有用这些类库，而不想引入时，这个注解不会触发 “类没有定义” 的异常。

### 5.2 Macroview-Lang 2.10.0

 + 新增：**ConcurrentRefrenceHashMap** 类，可以用作缓存。（内存紧张时，缓存的内存能被 GC 回收）

 + 新增：**StringArrays** 类，是一个字符串数组，可替换 String[]。

 + 新增：**StringObjectMap** 类，这是一个 LinkedHashMap<String, Object>，提供一些方便使用方法

 + 新增：**ArrayListEx** 类，对 ArrayList 做一些扩展，方便和简化使用

### 5.3 Macroview-DB 2.10.0

　　`MD`新版本对数据查询提供了比较大的支持，只要包括在以下两方面：

#### 5.3.1 增强 select() 方法

　　`select()`方法在 `2.8.0`就已经引入，不过功能一般般。但在 `2.10.0` 里，几乎覆盖了所有的查询表达式内容，下面列出 `select()`在查询方面的增强内容：

 + **columns(field...)**：查询这段列表，如果没有表示为 `*`
 + **distinct(fields)**：支持字段的 DISTINCT （即去掉重复）操作
 + **gt(field, value)**：大于
 + **ge(field, value)**: 大于等于
 + **lt(field, value)**：小于
 + **le(field, value)**：小于等于
 + **like(field, value)**：字符串的包含
 + **startsWith(field, value)**：以什么开头的字符串
 + **endWith(field, value)**：以什么结尾的字符串
 + **in(field, values)**：in 操作（在）
 + **notIn(field, values)**：not in 操作（即不在）
 + **between(field, Range)**：between 操作
 + **eq(field, value)**：相等
 + **neq(field, value)**：不等
 + **isNull(field)**：为 null
 + **notNull(field)**：不为 null
 + **inSubQuery(field, QueryModel)**：in 子查询
 + **leSubQuery(field, QueryModel)**：小于等于一个子查询
 + **ltSubQUery(field, QueryModel)**：小于一个子查询
 + **geSubQuery(field, QueryModel)**：大于等于一个子查询
 + **gtSubQuery(field, QueryModel)**：大于一个子查询
 + **beginOr()**：后面跟的表达式为 Or 操作
 + **closeOr()**：结束 Or 操作，后面的表达式回归 And 操作
 + **limit(count)**：限制记录数
 + **desc(fields)**：以指定字段倒序排列
 + **asc(fields)**：以指定字段顺序排列
 + **groupBy(fields)**：按指字字段分组
 + **having(express)**：对分组内容进行筛选

　　下面是一些操作示例：

```java
   Wifidevicelog.dao.select()
                    .columns("authenNumber","openId","signIn","signOut","onlineTotal","authenType","deviceMac")
                    .eq("authenNumber", reportBean.getAuthenNumber)
                    .eq("authenType", reportBean.getAuthenType().name())
                    .eq("wlcName", reportBean.getWlcName())
                    .between("createTime", DateTimeRange.getInstance(reportBean.getBeginTime(), reportBean.getEndTime()))
                    .notNull("signOut")
                    .query();
```

　　相当于下面的 `SQL`语句：

```sql
 select authenNumber,openId,signIn,signOut,onlineTotal,authenType,deviceMac from wifidevicelog where authenNumber=? And authenType=? And wlcName=? And (createTime between ? and ?) and signOut is not null
```

　　表达式“或”（or）的操作示例：

```java
    User.dao.select()
            .columns("name", "jobTitle")
            .beginOr()
            .like("name", "David")
            .like("name", "Toney")
            .closeOr()
            .in("id", "1", "2", "6", "7", "8")
            .limit(5)
            .query();
```
　　相当于：
```sql
  SELECT `name`, `jobTitle` FROM `User`  WHERE ((((`name` like ?) OR (`name` like ?)) AND (`id` in (?,?,?,?,?))) )
```

```java
    User.dao.select()
            .notNull("jobTitle")
            .between("createTime", 
                        DateTimeRange.createInstance(
                            "2016-02-10 14:42:38 ~ 2016-04-10 14:42:38", 
                            "yyyy-MM-dd HH:mm:ss"))
            .desc("age")
            .groupBy("jobTitle")
            .query();
```

```java
    MobileStationLog.dao.select()
                        .distinct("mac")
                        .like("mac", "00:1e")
                        .limit(10)
                        .query();
``` 

　　除了查询表达式增强之外，在查询结果方面也提供了丰富的方法：

 + **query()**：执行查询，返回列表
 + **query(Class)**：执行查询，返回指定类的对象列表
 + **map(Class)**：就是 query(Class<?>)
 + **findOne()**：执行查询，返回第一条记录（如果有多条的话）
 + **first()**：返回查询结果的第一条记录
 + **findOne(Class)**：执行查询，用第一条记录来填充指定类的对象并返回
 + **findOneColumn(field)**：执行查询，返回第一条记录中，指定 field 的值（单个值）
 + **findAllByColumn(field)**：执行查询，返回所有记录中，指定 field 的值（列表）
 + **findAllByColumn(field, Class)**：执行查询，返回所有记录中，指定 field 的值（列表，并返回具体的类型，这些类型通常是 String, Integer, Date, Long 等基础类型）
 + **getColumns(fields)**：相当于 columns(fields).query()，即执行查询，返回记录中指定的字段的值
 + **getColumnMap(field1, field2)**：执行查询，返回一个 Map，其中 field1 的值为 Map 的Key，field2的值为 Map 的值
 + **count()**：返回查询记录数
 + **exists()**：是否存在符合查询条件的记录（存在性判断）

　　分页方面的方法：

 + **pagination(PageRquest)**：按 `PageRequest` 提供的页码，页大小等进行分页查询
 + **pagination(PageRequest, Class)**：按 `PageRequest` 提供的页码，页大小等进行分页查询，查询结果是 Class 类对象

　　下面是一些查询示例：

```java
    User.dao.select()
            .neq("name", "manager")
            .in("id", "1,2,3,4,5,6,7")
            .asc("name")
            .desc("jobTitle")
            .groupBy("jobTitle")
            .having("count(jobTitle)>1")
            .query(UserBean.class);      //返回 List<UserBean>，而不是 List<User>
```

```java
    //分页操作
    //分页数据对象
    Page<WifiUserLog> page = new Page<>();
    page.setPageSize(6);

    page = WifiUserLog.dao.select()
                          .notNull("signIn")
                          .notNull("signOut")
                          .gt("timeQuote", 0)
                          .desc("createTime")
                          .pagination(page);
```

#### 5.3.2 d() 方法

　　这是一个新增的方法，用来进行有条件删除和更新，主要方法包括：

 + **delete()**：删除记录
 + **delete(Consumer)**：删除记录，并提供删除异常处理
 + **update(field, value)**：更新满足条件记录的某个字段值
 + **update(fields, values)**：更新满足条件记录的某些字段值

#### 5.3.3 join() 方法

　　这是新增的方法，提供连接支持，包括内连接，左连接，右连接。连接操作是基立在 `select()`基础上，所以能够使用 `select()`的所有方法。

　　`Model`（实体类基类）提供了下面几个 `join()`方法： 

 + **join(targetClass)**：与 `targetClass`建立内连接

```java
    WifiDeviceLog.dao.join(OnlineWifiDevice.class)
                     .on("deviceMac", "deviceMac")
                     .query();
```

 + **join(targetClass, leftKey, rightKey)**：相当于 join(targetClass).on(leftKey, rightKey)

```java
    WifiDeviceLog.dao.join(OnlineWifiDevice.class, "deviceMac", "deviceMac")
                     .query();
```

 + **join(targetClass, JoinType)**：与 `targetClass`建立 `JoinType` 指定的连接

```java
    WifiDeviceLog.dao.join(OnlineWifiDevice.class, JoinType.LEFT_JOIN)  //连接类型：左连接
                     .on("deviceMac", "deviceMac")
                     .query();
```

 + **join(targetClass, alias)**：为连接对象提供一个别名

```java
    WifiDeviceLog.dao.join(OnlineWifiDevice.class, "od")  //别名：od
                     .on("deviceMac", "deviceMac")
                     .query();

    //结果：select `wifidevicelog`.`*`, `onlinewifidevice`.`*` from `wifidevicelog` join `onlinewifidevice` AS `od` on `od`.`deviceMac`=`wifidevicelog`.`deviceMac`
```

 + **join(targetClass, alias, JoinType)**：为连接对象提供一个别名

　　使用 `join()`方法后，会进入到 `select()` 对象，并使用其丰富的查询表达式来查询数据。

　　除了两表关联之外，还支持更多表的关联，下面是操作示例：

 + **innerJoin(targetClass)**
 + **leftJoin(targetClass)**
 + **rightJoin(targetClass)**

```java
    WifiDeviceLog.dao.join(OnlineWifiDevice.class)
                     .on("deviceMac", "deviceMac")
                     .leftJoin(WifiUser.class)
                     .on("clientMac", "deviceMac")
                     .le("onlineTotal", 1000)
                     .limit(5)
                     .query();

    //WifiDeviceLog JOIN OnlineWifiDevice ON WifiDeviceLog.deviceMac=OnlineWifiDevice.deviceMac Left Join WifiUser On wifiuser.clientMac=WifiDeviceLog.deviceMac
```

 + **innerJoin(targetClass, leftKey, rightKey)**
 + **leftJoin(targetClass, leftKey, rightKey)**
 + **rightJoin(targetClass, leftKey, rightKey)**

```java
    WifiDeviceLog.dao.join(OnlineWifiDevice.class, "deviceMac", "deviceMac")
                     .leftJoin(WifiUser.class, "clientMac", "deviceMac")
                     .le("onlineTotal", 1000)
                     .limit(5)
                     .query();

    //WifiDeviceLog JOIN OnlineWifiDevice ON WifiDeviceLog.deviceMac=OnlineWifiDevice.deviceMac Left Join WifiUser On wifiuser.clientMac=WifiDeviceLog.deviceMac
```

 + **innerJoin(targetClass, leftKey, rightAlias, rightKey)**
 + **leftJoin(targetClass, leftKey, rightAlias, rightKey)**
 + **rightJoin(targetClass, leftKey, rightAlias, rightKey)**

```java
    WifiDeviceLog.dao.join(OnlineWifiDevice.class, "od")
                     .on("deviceMac", "deviceMac")
                     .leftJoin(WifiUser.class, "clientMac", "od", "deviceMac")
                     .le("onlineTotal", 1000)
                     .limit(5)
                     .query();

    //WifiDeviceLog JOIN OnlineWifiDevice AS od ON WifiDeviceLog.deviceMac=od.deviceMac Left Join WifiUser On wifiuser.clientMac=od.deviceMac
```

```java
    //分页操作
    //分页数据对象
    Page<WifiUserLog> page = new Page<>();
    page.setPageSize(6);

    WifiDeviceLog.dao.join(OnlineWifiDevice.class, "od")
                     .on("deviceMac", "deviceMac")
                     .leftJoin(WifiUser.class, "clientMac", "od", "deviceMac")
                     .le("onlineTotal", 1000)
                     .pagination(page);
```

```java
    WlcAclTable.dao.alias("a")
                   .join(WlcAclRecord.class, "r", JoinType.LEFT_JOIN)
                   .on("aclId", "id")
                   .columns("a.*", "count(r.id) AS ruleCount")
                   .eq("a.wlcName", wlcName)
                   .groupBy("a.name")
                   .asc("a.id")
                   .query();
```

```sql
   Select a.*, count(r.id) AS ruleCount From WlcAclTable a 
   left Join WlcAclRecord r On a.id=r.aclId 
   Where (wlcName=?) Group By a.name Order By a.id
```

#### 5.3.4 查询接口：SqlQueryExecutor

　　`SqlQueryExecutor`意图很明显，当我们使用 `select()`（或s()）、`join()`（或j()）创建了查询结构时，不想立即执行查询，而是想将这个查询结构作为参见进行传递时，查询接口就能这样使用。

```java
  //将查询结构作为对象返回，要留意：查询链中，最后一步并没有加上 query(), findOne() 等方法
  public SqlQueryExecutor createMobileStationLogQuery(String mac, int limit){
  
      return MobileStationLog.dao.select()
                        .distinct("mac")
                        .like("mac", mac)
                        .limit(limit);
  }

  //在适当的地方再执行，不过此时已经不能再添加额外的查询条件
  SqlQueryExecutor executor = createMobileStationLogQuery("01:0c", 10);
  
  executor.query();  //query(), findOne .....等查询方法
```  
  
### 5.4 Macroview-App-Base 2.10.0  
  
　　`Macroview-App-Base` 是对应用的一种抽象，为具体的应用模块提供基础抽象代码。例如，登录方面的抽象，分页抽象等等

#### 5.4.1 进一步明确 FieldConfigBean 与 FieldConfig 注解含义

　　`FieldConfigBean`与`FieldConfig`注解，可以用来自动构建 Web Form，只需要通过注解，就能得到一个 Web Form 界面，并且具备读取与保存的功能，从而方便和简化了相关工作。

　　当然，目前此项工作仅限于配置方面，未来不排除有更广泛的使用。

　　在 `2.10.0` 之前的版本当中，此注解只会影响到 Web Form 的显示，并没有约束到保存。换言之，只要被注解的类存在字段，此字段无论是否添加了`FieldConfig`注解，都会更新到配置表。

　　而在新的 `2.10.0`（或更高版本）当中，加强了更新约束，必须要添加注解的字段，才会被更新，当然为了为那些不显示，但有可能会变更的配置项要保存，这种需求提供了解决方案：

 + FieldConfig 注解引入 `show` 属性，用来决定配置项是否在 web form 中显示

 + 输入类型当中引入 `HIDDEN`（隐藏字段）类型，作为隐藏字段显示在 web form 当中

　　但是，无论何种方案，想字段的值保存（或更新）到配置表中，就必须要添加 `FieldConfig` 注解。
