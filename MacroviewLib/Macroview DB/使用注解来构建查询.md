
@[toc](目录)

### ※ 文档摘要

　　描述如何使用注解来构建查询，避免拼接查询语句，减少错误，提高可维护性和更加优雅实现查询

### ※ 查询 Bean

　　作为查询 Bean，可以是任意的 `Pojo`对象，不过在编写时要注意：

 + **Bean 的字段必须对应前端查询提交的字段，而提交的查询值将赋给这个字段**

　　例如 `输入用户名：<input type="text" name="userName">` 查询用户名，查询字段为`userName`，那么在编写与之对应的查询 Bean时，就需要给Bean添加`userName`属生字段。

```java
 /* 查询 Bean，之所以继承自  DefaultPageBean 是做分页查询，如果不分页，不需要继承 */
public class QueryBean extends DefaultPageBean{

   /* 使用 @Like 注解，相当于  where (userName like 'xxx') 这样的查询条件 */
   @Like
   private String userName;  //这个属性的名称与  <input name="userName"> 相呼应
   
   //下面 set/get 略
}
```


### ※ 常用查询注解

 + **@Equals**

　　实现“==”的查询，这是比较常用的查询。另外，如果某字段默认不添加任何查询注解的情况下，也看作是`@Equals`注解。所以，对于相等的查询，可以不加这个注解。

```java
 /* @Equals 可以不加 */
 @Equals
 private String serverStatus; // 相当于条件： serverStatus = ?
```

 + **@Like** ：实现`like`的查询，这个查询主要是字符串的`相似`(模糊)查询。对于`相似`查询，目前支持下面三种：

   - 前缀。也就是前面部分要相同的意思，相当于 `like 'value%'`，只要前面是 `value`才对。

   - 包含。也就是只要有就相同的意思。相当于 `like '%value%'`，是一种包含的查询。

   - 后缀。也就是最未的部分要相同的意思，相当于`like '%value'`，必须存在于末尾。

　　`@Like`注解所带的参数`type`，就是体现出上述的查询类型。当不带参数时，默认为`包含`操作。

```java
 /* 前缀 */
 @Like(type=LikeType.StartsWith)
 private String ip;  // 相当于： ip like 'value%'，例如提交 ip=192.168 => ip like '192.168%'

 /* 包含 */
 @Like(type=LikeType.Contains)
 private String title; // 相当于： title like '%value%'

   /**
    * 后缀匹配，相当于 fileExt like '%value'，意思：必须后面部分相同，才相似...
    */
 @Like(type=LikeType.EndsWith)
 private String fileExt;

 /**
  * 不带任何参数的情况下，默认为 @Like(type=LikeType.Contains)
  */ 
  @Like
  private String content;
```

 + **@NotEquals**，表示不等于于(`<>`)

```java
 /* 不等于 */
 @NotEquals
 private int number;
```

 + **@NotNamed**，表示查询 Bean 中不参与查询的字段。

　　在一个 Bean 中，往往会存在一些辅助字段属性，这些属性并不会用于查询（语句）。此时，需要使用这个注解来明确说明。

 + **@Min**，大于或等于。相当于“>=”。
  
```java
 /* age >= value */
 @Min
 private int age;
```

 + **@Max**，小于或等于。相当于“<=”。

 + **@Between**，两者之间，相当于“between...and”操作。
 
    要注意，使用本注解的字段必须要实现 `com.macroview.commons.base.Range< T >` 接口.

    目前，在 macroview-lang 类库中，我们已经提供了三个常用的 Range 接口实现：

    - DateTimeRange: 这是用于日期的范围表示，可以用于一个日期范围的查询。
  
    - IntegerRange：这是整数的范围表示，可以用于一个整数范围的查询。
  
    - LongRange：这是长整数的范围表示，可以用于一个长整数范围的查询。

　　`@Between` 最常使用的情景，就是时间范围查询，下面以时间为例来说明注解的使用。

```java
    /**
    * 使用时间范围查询，要留意：createTime 是查询 Bean 属性，将不出现在客户端
    */
    @Between
    private DateTimeRange createTime;
  
   /**
    * 这个属性出现在客户端，作为日期时间范围的开始部分（开始日期）
    * 不参加查询，对应  Web 的开始时间，是用来 组成  createTime 的内容
    */
    @NotNamed
    private Date beginTime;
    
    /**
    * 这个属性出现在客户端，作为日期时间范围的结束部分（结束日期）
    * 不参加查询，对应 web 的开始时间，是用来组成 createTime 的内容
    */
    @NotNamed
    private Date endTime;
    
   /**
    * 时间的查询范围，利用客户端的提交，按需要构建 Range 的实现
    * @return the createTime
    */
    public DateTimeRange getCreateTime() {
      if(beginTime == null || endTime == null)
        return null;
      
      createTime = new DateTimeRange(beginTime, endTime);
      
      return this.createTime;
    }
  
    /**
    * @return the beginTime
    */
    public Date getBeginTime() {
      return beginTime;
    }
  
    /**
    * @param beginTime the beginTime to set
    */
    public void setBeginTime(Date beginTime) {
      this.beginTime = beginTime;
    }
  
    /**
    * @return the endTime
    */
    public Date getEndTime() {
      return endTime;
    }
  
    /**
    * @param endTime the endTime to set
    */
    public void setEndTime(Date endTime) {
      this.endTime = endTime;
    }
  }  
```

 + **@OrderBy**，定义排序字段。

    使用本注解可以注解要排序的字段。本字段相对其他字段独立，可以与其他注解一起使用。有两个值：Direction.ASC 和 Direction.DESC（默认）。

    可以定义多个排序字段。
  
```java

  /**
   *  定义 id 为排序字段，相当于  @OrderBy(Direction.DESC)，因为 Direction.DESC 是默认内容
   */
  @OrderBy
  private Long id;
  
  /**
   * 按字典顺序排
   */
  @OrderBy(Direction.ASC)
  private String status;

  /**
   * 可以同其他的注解一起使用
   */
  @OrderBy(Direction.ASC)
  @Like
  private String title;
```

 + **@CustomConditions**，自定义查询条件。这个使用就比较灵活，可以表述一些特殊的查询。
  
　　`@CustomConditions` 包含了两个参数：`value` 和 `ignoreField`。`value` 就是查询表达式内容，而 `ignoreField` 表示所注解的属性的值可以参与也可以不参与，`ignoreField=true` 表示所注解的字段将不参与到查询式子内，`ignoreField=false` 表示所注解的字段将参与查询，默认为 `ignoreField=false`。

　　由于在某些特定的查询中，可能需要加入一些优化查询手段，而这些手段并不需要 Bean 的字段参与，在这种情况下，可以使用 `ignoreField=true`来明确此字段不参与查询条件。

```java

  /**
   * 本查询表达式的意思： updateDate 与 字段 createTime 日期中的天相差为0(即同一天)。其中表达式中的“?”，就是所注解字段的值
   */
  @CustomConditions("DATEDIFF('DAY', createTime, ?)=0")
  @Temporal(TemporalType.DATE)
  private Date updateDate;
```

　　从示例可以看出来，我们可以使用 @CustomConditions 来定制一些带函数（即数据库内置函数）的特定表达式，这样使得构建查询更加灵活与复杂。   

　　最后以一个完整的示例来展示注解查询的应用：

```java
/**
 * 查询 WifiDeviceLog 的Bean
 *
 * @author Jai
 * @since: v1.0
 */
public class WifiDeviceLogQueryBean extends DefaultPageBean{

	private final static Logger logger = Logger.getLogger(WifiDeviceLogQueryBean.class);
	
	/**
	 * 如果是手机就是手机号码，如果不是；就是设备的逻辑编号，例如微信号，员工编号等
	 */
	@Like
	private String authenNumber;
	
	/**
	 * 设备的 mac 地址
	 */
	@Like
	private String deviceMac;
	
	@Like
	private String apMac;

	/**
	 * 设备的认证方式
	 */	
	private String authenType;
	
	/**
	 * 登录时间范围
	 */
	@Between
	private DateTimeRange signIn;

	/**
	 * 用来构建 signIn 时间范围
	 */
	@NotNamed
	private String signInRange;
	
	/**
	 * 退出时间范围
	 */
	@Between
	private DateTimeRange signOut;
	
	/**
	 * 用来构建退出时间范围
	 */
	@NotNamed
	private String signOutRange;
	
	/**
	 * 设备类型
	 */
	private String deviceType;

	/**
	 * @return the authenNumber
	 */
	public String getAuthenNumber() {
		return authenNumber;
	}

	/**
	 * @param authenNumber the authenNumber to set
	 */
	public void setAuthenNumber(String authenNumber) {
		this.authenNumber = authenNumber;
	}

	/**
	 * @return the deviceMac
	 */
	public String getDeviceMac() {
		return deviceMac;
	}

	/**
	 * @param deviceMac the deviceMac to set
	 */
	public void setDeviceMac(String deviceMac) {
		this.deviceMac = deviceMac;
	}

	/**
	 * @return the apMac
	 */
	public String getApMac() {
		return apMac;
	}

	/**
	 * @param apMac the apMac to set
	 */
	public void setApMac(String apMac) {
		this.apMac = apMac;
	}

	/**
	 * @return the authenType
	 */
	public String getAuthenType() {
		return authenType;
	}

	/**
	 * @param authenType the authenType to set
	 */
	public void setAuthenType(String authenType) {
		if(StringUtils.stringNotEmpty(authenType) && !"*".equals(authenType.trim())){
			this.authenType = authenType;
		}else{
			this.authenType = null;
		}
	}

	/**
	 * @return the signIn
	 */
	public DateTimeRange getSignIn() {
		return signIn;
	}

	/**
	 * @param signIn the signIn to set
	 */
	public void setSignIn(DateTimeRange signIn) {
		this.signIn = signIn;
	}

	/**
	 * @return the signInRange
	 */
	public String getSignInRange() {
		return signInRange;
	}

	/**
	 * @param signInRange the signInRange to set
	 */
	public void setSignInRange(String signInRange) {
		if(StringUtils.stringNotEmpty(signInRange)){
			try{
				this.signIn = DateTimeRange.createInstance(signInRange, "yyyy/MM/dd");
			}catch(Exception e){
				logger.error("[设备历史查询 Bean]==> 所传入的时间范围参数[" + signInRange + "]格式或内容不正确，应该是[yyyy/MM/dd - yyyy/MM/dd]格式的字符串，异常：", e);
			}
		}
		this.signInRange = signInRange;
	}

	/**
	 * @return the signOut
	 */
	public DateTimeRange getSignOut() {
		return signOut;
	}

	/**
	 * @param signOut the signOut to set
	 */
	public void setSignOut(DateTimeRange signOut) {
		this.signOut = signOut;
	}

	/**
	 * @return the signOutRange
	 */
	public String getSignOutRange() {
		return signOutRange;
	}

	/**
	 * @param signOutRange the signOutRange to set
	 */
	public void setSignOutRange(String signOutRange) {
		
		if(StringUtils.stringNotEmpty(signOutRange)){
			try{
				this.signOut = DateTimeRange.createInstance(signOutRange, "yyyy/MM/dd");
			}catch(Exception e){
				logger.error("[设备历史查询 Bean]==> 所传入的时间范围参数[" + signOutRange + "]格式或内容不正确，应该是[yyyy/MM/dd - yyyy/MM/dd]格式的字符串，异常：", e);
			}
		}
		
		this.signOutRange = signOutRange;
	}

	/**
	 * @return the deviceType
	 */
	public String getDeviceType() {
		return deviceType;
	}

	/**
	 * @param deviceType the deviceType to set
	 */
	public void setDeviceType(String deviceType) {
		if(StringUtils.stringNotEmpty(deviceType) && !"*".equals(deviceType.trim())){
			this.deviceType = deviceType;
		}else{
			this.deviceType = null;
		}
	}
	
}
```



