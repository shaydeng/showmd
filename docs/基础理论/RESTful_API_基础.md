## 1. 说明

　　本文用来解释`RESTful`式的`API`的结构组成及基础知识。

## 2. 内容

### 2.1 RESTful 概念

　　`RESTful`的全称是：Resources Representational State Transfer，即“资源描述状态转换”。可通俗理解为，根据请求意愿，组织（格式化）所需的资源，并将结果回传（给请求者）的系统设计风格。

　　`RESTful`的特点：

 + 资源（Resource）。在系统中，所有数据（包括文件、媒体等），都统称为资源。

 + 资源的描述与定位（Representation）。同一资源能够以多种形态对外提供，并有其特定的位置与特征描述。

 + 状态转移（State Transfer）。

 + 统一接口（基于 HTTP/HTTPS）

 + 超文本驱动（Hypertext Driver）。有别于传统的数据记录，系统完全基于 http 协议之上，对外提供各种协议所定义的资源（超文本）。

　　由于 `RESTful`本身的提出，就是建筑在 `HTTP`协议之上。因此，`RESTful`的实现也就跟 `HTTP`协议密不可分，从而继承或具有从 `HTTP`协议那里得来的优势（或说约束）：

 + 客户端-服务器（Client-Server）形式架构。行为通常由客户端发起请求，而服务器对请求进行响应，属于典型的“请求-响应”工作模式。

 + 无状态（Stateless）。无状态的通信方式，使得每个请求相对独立。每次请求的完成，都没后顾之忧，从而使得服务器的处理简单快捷，大大提高了服务器的处理能力。

 + 缓存（Cache）。由于工作的无状态特性，使得响应内容能够被很好地缓存，从而提高系统的工作效率。

 + 统一接口（Uniform Interface）。基于简单和结构一致的 `HTTP`协议之上，因此整个系统有着统一的通信方式，提高交互的可见性。

 + 分层系统（Layered System）。通过限制组件的行为（即，每个组件只能“看到”与其交互的紧邻层），将架构分解为若干等级的层。


### 2.2 资源

　　资源在`HTTP`协议中，是一个相当宽泛的概念（超文本），可以是文字、图片、视频等。

### 2.3 资源的描述与定位

　　`RESTful`是建立在 `HTTP`协议之上，因此资源的描述与定位，也使用了`HTTP`协议的内容。

#### 2.3.1 URL--资源描述

　　URL 的特点与结构要素：

 + **每个 URL 只定位一种资源**。换句话说，URL 指向的应该是资源。

 + **URL 所使用的应该是名词，而不是表述行为的动词**。

 + **URL 可以放入版本号，以支持多版本情形**

 + **URL 中嵌入子URL，或者使用过滤条件来获取资源的子集**

　　`URL` API 的结构：

      http://host:port/api/v1/endpoints

      - http://host:port/api/v1 部分又称为 `API Root URL`，即 API 的根 URL。

         /api : 表示这条 URL 是属于 API 类型。这种类型性质的指示，也可以使用域名来进行，例如：

            http://api.example.com

         /v1 ：表示 API 的版本

      - endpoints 部分是具体一个资源或资源集的描述。描述的方式通常是由抽象到具体，由大类到小类再到个体等。

　　下面是一些资源描述示例：（以动物园和动物为例）

 + **/zoos** : 表示所有动物园

 + **/zoos/zid** ：表示具体的一家动物园

 + **/zoos/zid/animals**：表示某家动物园中所有动物

 + **/zoos/zid/animals/aid**：表示某家动物园中某只动物

 + **/animals**：从动物视角来看，表示所有动物。

 + **/animals/aid**：表示动物集合中的某只动物

 + **/animal_types**：表示所有动物种类

 + **/employees**：表示所有员工

 + **/zoos/zid/employees**：表示某家动物园的所有员工

#### 2.3.2 HTTP 请求参数 -- 资源过滤条件

　　客户端对资源的请求，往往具有针对性（而不仅限于所有），也就是针对某些符合条件的资源。因此，如何过滤或筛选符合条件的资源，也是非常重要的内容，特别是对于数量比较大的资源。

　　HTTP 协议本身就提供了添加过滤筛选条件的方法，其中最方便也最常用的，就是请求参数：

      URL?请求参数列表。请求参数列表放在 `URL` 的后面，由一组"key=value"，再使用 "&" 连接起来的字符串。

　　下面是一些请求参数示例：

      - ?limit=10 ：限制资源的返回数量（例如分页）

      - ?offset=10 ：指定开始位置（也一组资源中，从 offset 开始返回）

      - ?animal_id=1 ：指定筛选条件（某个属性值）

      - ?page=2&per_page=20 ：指定第几页，并且每页多少条资源

      - ?sortby=name&order=asc：指定返回结果前，资源先按 name 属性，以 asc 方向排序

#### 2.3.3 HTTP Headers 请求头 --- 公共参数传递

　　对于系统的公用参数，又或者系统底层的参数（特别是不需要手工干预的），在请求参数中传递显然不是明智的选择，此时`HTTP`协议请求头（Headers）就是使用首选。

　　请求头数据通常是预先定义，又或者是一次性定义（也能添加使用时限），然后系统在不需要人手干预的情况下，自动处理这些数据。

 + **Authorization**

    `HTTP Basic`认证方式，就是通过 `Header`来进行。

 + **token 值**

    当涉及到系统的安全性时，大部分的应用会通过`Header`来传递认证`Token`。

 + **Conten Type**（资源类型标识)

    在 `Header`中明确指示返回的资源格式。（JSON, HTML, TEXT, XML 等）

 + **应用识别**

    服务器往往会针对不同类型的客户端，进行个性化识别与服务，因此可以通过 `Header`来提供客户端类型标志。例如通过 `x-co-app: *-type`请求头来标识，具体如 `x-co-app: *-ios`表示 IOS；`x-co-app: *-android`表示 Android 机等

 + **限制性标志** （如速率限制）

   - X-RateLimit-Limit: 每个IP每个时间窗口最大请求数

   - X-RateLimit-Remaining: 当前时间窗口剩余请求数

   - X-RateLimit-Reset: 下次更新时间窗口的时间（UNIX时间戳），达到下个时间窗口时，Remaining恢复为Limit

　　等等。

#### 2.3.4 HTTP 协议请求操作

　　`URL`是资源的描述，那么如何获取和操作这些资源，则是由 `HTTP`协议的请求动作来完成，`HTTP`协议定义了以下几种操作（动词）：

 + **GET**：资源的读操作，GET URL 表示读取一项或多项（集合）资源。

    读操作并不会对资源进行变更，同一个 GET URL 操作应该得到相同的结果。

 + **POST**：资源的创建操作，POST URL 表示创建一个资源。

    创建操作表示创建一个不存在的资源，每次操作都会创建一个新资源。

 + **PUT**：资源的更新操作，PUT URL 表示对已经存在的资源进行更新

    更新操作是针对已经存在的资源，同一个 PUT URL 应该得到相同的更新结果。（更新的幂等性）

 + **DELETE**：资源的删除操作，DELTE URL 表示对已经存在的资源进行删除

 + **PATCH**：资源的更新操作，通常被 `PUT`操作替代

    PATCH 操作与 PUT 操作不同点在于：PUT 的更新通常要提交完整的资源，而 PATCH 只提交更新的部分即可，但在实际使用中，通常只使用 PUT 来做所有的更新动作，甚少使用 PATCH

 + **HEAD**：获取资源的元数据。（甚少使用）

 + **OPTIONS**：获取资源的可编辑信息，以知道资源的那些属性是可修改的。（甚少使用）

　　使用上面的动词，再配合 URL 的描述，我们就能得到完整的请求（操作）示例：

 + **GET /zoos**：获取所有动物园资料

 + **POST /zoos**：创建一家动物园。（看出 POST 与 GET 的不同，虽然 URL 相同）

 + **GET /zoos/zid**：获取某家动物园资料

 + **PUT /zoos/zid**：更新某家动物园资料

 + **DELETE /zoos/zid**：删除某家动物园

 + **GET /zoos/zid/animals**：获取某家动物园所有动物

 + **POST /animals**：创建一只动物（记录），这是一个宽泛的创建操作

 + **POST /zoos/zid/animals**：在指定动物园中创建一只动物，这个创建动作就具体得多。

#### 2.3.5 HTTP 状态码 --- 对请求的响应

　　服务器端对每个客户端请求，都会返回特定的状态码，以表示请求的处理状态。同样，`RESTful` API 也能使用这些状态码来表述 API 的执行情况。

 + **200 OK**

    `HTTP 200 OK`状态码，通常表达请求执行成功。但也可以准确地用在 `GET`操作上，表示服务器成功返回请求的资源，并且这个操作是幂等的（即无论多少次该操作，结果都相同）。

 + **201 CREATED**

    `HTTP 201 CREATED`状态码，通常表达成功创建或更新了资源。这一状态码更多用于 `POST/PUT/PATCH`操作上，用来表示请求操作成功完成。

 + **202 ACCEPTED**

    `HTTP 202 ACCEPTED`状态码表示请求已经收到，并放入后台队列，这一状态常用于 `异步请求任务`。

 + **204 NO CONTENT**

    `HTTP 204 NO CONTENT`状态码表示资源已经不存在（被删除），常用于`DELETE`成功删除资源操作。

 + **400 INVALID REQUEST**

    `HTTP 400 INVALID REQUEST`状态码表示请求错误，操作无效。这一状态码常用于 `POST/PUT/PATCH`操作，表示操作无效，服务器没有进行更新或创建工作，此时请求操作也是幂等的（即无论多少次这样请求，结果都一样，不会对服务器资源产生改变）
 + **401 Unauthorized**

    `HTTP 401 Unauthorized`状态码表示用户没有操作权限（令牌、用户名、密码错误）。这一状态码对于所有请求操作都有效，只要请求操作需要操作权限的话。

 + **403 Forbidden**

    `HTTP 403 Forbidden`状态码涉及到授权的问题，表示禁止访问。这一状态码同样对于所有请求操作都有效。

 + **404 NOT FOUND**

    `HTTP 404 NOT FOUND`状态码表示所请求的资源不存在，同时服务器也没有进行任务操作。这一状态码对所有请求操作都有效，并且也是幂等的。

 + **406 Not Acceptable**

    `HTTP 406 Not Acceptable`状态码表示所请求的资源（格式）不可得，数据是存在，但要求的格式不存在。例如数据只能以 `XML`格式输出，而请求要`JSON`格式，就是这种不可得情况。

 + **500 INTERNAL SERVER ERROR**

    `HTTP 500 INTERNAL SERVER ERROR`状态码表示服务器发生错误，请求的结果无法保证其正确性。请求本身的问题，还是服务器处理请求时出错，都不能确定。


